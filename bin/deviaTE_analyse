#!/usr/bin/env python3

import argparse
import pysam
import deviaTE.deviaTE_pileup as pileup
from deviaTE.deviaTE_IO import get_data


# set up parser and arguments
parser = argparse.ArgumentParser()
parser.add_argument('--input', required=True, help='alignment file to be analysed')
parser.add_argument('--family', required=True, help='TE family to analyse')
parser.add_argument('--library', help='path to alternative reference sequence library')
parser.add_argument('--output', help='name of output table')
parser.add_argument('--sample_id', help='sample identifier')
parser.add_argument('--annotation', help='alternative annotation in gff-format')
parser.add_argument('--log', help='logfile from preparation script')
parser.add_argument('--no_freq_corr', action='store_true', help='deactivate frequency correction for internal deletions')
args = parser.parse_args()

if args.sample_id is None:
    args.sample_id = args.input

if args.output is None:
    args.output = args.sample_id + '.' + args.family

if args.library is None:
    args.library = get_data('lib/te_library')

if args.annotation is None:
    args.annotation = get_data('lib/te_features.gff')

sample = pileup.Sample(name=args.sample_id, fam=args.family, lib=args.library,
                       anno=args.annotation, log=args.log, bam=args.input)
# get reference of family
sample.get_ref()

if sample.refseq is None:
    raise ValueError('Selected family is not in references. Typo? ' + args.family)

# get annotation for family
sample.get_anno()

if len(sample.fam_anno) is 0:
    print('no annotaions found for: ' + args.family)

# search logfile for normalization factor
sample.get_norm_fac()

# fill sites of sample
c = 0
for base in sample.refseq:
    sample.sites.append(pileup.Site(pos=c, refbase=base, sid=args.sample_id, fam=args.family))
    c += 1

# perform pileup
sample.perform_pileup(min_int_del_len=20, min_trunc_len=10, min_indel_len=2)

# process extracted data
for s in sample.sites:
    s.sum_coverage()
    s.is_snp(min_count=5, min_freq=0.05, A=s.A, C=s.C, G=s.G, T=s.T, cov=s.cov)
    s.filter_IND(att='int_del', min_count=3, norm_fac=sample.norm_fac)
    s.filter_IND(att='ins', min_count=5, norm_fac=sample.norm_fac)
    s.filter_IND(att='delet', min_count=5, norm_fac=sample.norm_fac)
    s.filter_trunc(min_trunc_count=3)
    s.check_annotation(anno=sample.fam_anno)
    if sample.norm_fac is not 1:
        s.normalize(norm_factor=sample.norm_fac)
        
# collect int dels and use to calc phys cov
sample.collect_int_dels()
sample.calc_phys_cov()

    
# estimate freqs., correct and parse new col
for int_del in sample.int_dels:
    if args.no_freq_corr == False:
        sample.mean_read_length()
        cf = pileup.correction_factor(sample.read_len)
        int_del.est_freq(sites=sample.sites, corr_factor=cf)
    else:
        int_del.est_freq(sites=sample.sites, corr_factor=1)
    int_del.write_freq(sites=sample.sites)


# write results
sample.write_frame(out=args.output)
print('analysis completed; table written to: ' + args.output)
